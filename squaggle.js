
(function() {

  // these words block squaggling: only squaggle stuff in between
  // (lists of words from types of words generated by gemini)
  const BARRIER_WORDS = new Set([
    // articles
    'a', 'an', 'the',
    // boring verbs + helpers
    'am', 'are', 'be', 'been', 'being', 'can', 'could', 'did', 'do', 'does',
    'had', 'has', 'have', 'is', 'may', 'might', 'must', 'shall', 'should', 'was',
    'were', 'will', 'would',
    // pronouns
    'he', 'her', 'hers', 'him', 'his', 'i', 'it', 'its', 'me', 'mine',
    'my', 'our', 'ours', 'she', 'their', 'theirs', 'them', 'they', 'us', 'we',
    'you', 'your', 'yours',
    'that', 'these', 'this', 'those',
    'what', 'which', 'who', 'whom', 'whose',
    'herself', 'himself', 'itself', 'myself', 'ourselves', 'themselves', 'yourself', 'yourselves',
    // pronouns-ish
    'all', 'an', 'another', 'any', 'both', 'each', 'either', 'enough', 'every', 'few',
    'less', 'little', 'many', 'more', 'most', 'much', 'neither', 'no', 'one', 'other',
    'several', 'some', 'such', 'the',
    // prepositions
    'about', 'above', 'across', 'after', 'against', 'along', 'among', 'around', 'at', 'before',
    'behind', 'below', 'beneath', 'beside', 'between', 'beyond', 'by', 'down', 'during', 'for',
    'from', 'in', 'inside', 'into', 'near', 'of', 'off', 'on', 'out', 'over',
    'past', 'since', 'through', 'throughout', 'to', 'toward', 'under', 'underneath', 'until', 'unto',
    'up', 'upon', 'with', 'without',
    // conjunctions
    'but', 'for', 'nor', 'so', 'yet',
    // 'or',
    'after', 'although', 'as', 'because', 'before', 'if', 'once', 'since', 'than', 'that',
    'though', 'till', 'unless', 'until', 'when', 'whether', 'while',
    // question words
    'how', 'when', 'where', 'why',
    // misc words i don't want squaggled
    'due', "like",
    // punctuation is also "words" here, don't want to squaggle across sentence boundaries
    '.', '?', '!', ';', ':', '\'', '-', '–', '—',
    '"', '\'', '(', ')', '[', ']', '{', '}', '<', '>',
  ]);

  // these words don't block squaggling but aren't squaggled.
  // want e.g. bacon, lettuce, and tomato -> tacon, bettuce, and lomato
  const GHOST_WORDS = new Set([
    'and', 'or', ','
  ]);

  // squaggle list of (node, startindex, word) tuples
  // this function is the one that actually applies modifications to the nodes
  function squaggleWords(wordlist) {
    if (wordlist.length <= 1) {
      return;
    }

    console.log("squaggling: ", wordlist);
  }

  // squaggles list of (node, text) tuples
  function squaggleSequence(seq) {
    let wordlist = [];
    for (const [node, text] of seq) {
      const wordregex = /\w+|[^\w\s]+/g;
      const matches = text.matchAll(wordregex);

      for (const match of matches) {
        let word = match[0];
        console.log("processing word: ", word);
        // hit barrier: current word list complete, send to squaggle and start over
        // (numbers are also barriers)
        let barrier = BARRIER_WORDS.has(word.toLowerCase()) || /\d/.test(word[0]);
        if (barrier) {
          squaggleWords(wordlist);
          wordlist = [];
        }
        else {
          wordlist.push([node, match.index, word]);
        }
      }
    }
    console.log("HERE");
    // squaggle anything left over
    if (wordlist.length) {
      // squaggleWords(wordlist);
    }
  }

  // squaggles children as a single unit
  function squaggleNode(root) {
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
    const sequence = [];

    let node;
    while (node = walker.nextNode()) {
      const text = node.nodeValue;

      // skip whitespace
      if (!text.trim()) {
        continue;
      }
      sequence.push([node, text]);
    }
    console.log("p sequence:", sequence);

    squaggleSequence(sequence);
  }

  // function processNode(node) {
  //   console.log("processing: " + node.tagName);
  //   if (!node.nodeValue || !(node.nodeValue.trim().length > 2)) {
  //     return;
  //   }

  //   let parent = node.parentElement;
  //   while (parent && parent !== document.body) {
  //     const tagName = parent.tagName.toUpperCase();
  //     if (tagName === 'SCRIPT' || tagName === 'STYLE' || tagName === 'NOSCRIPT' || tagName === 'CODE' || tagName === 'PRE') {
  //       return;
  //     }
  //     parent = parent.parentElement;
  //   }

  //   console.log(node.nodeValue);
  //   node.nodeValue = 'a' + node.nodeValue;
  // }

  function walkAndSquaggle(rootNode) {
    console.log("SQUAGGLE");
    const ps = document.querySelectorAll('p');
    for (p of ps) {
      squaggleNode(p);
      break;
    }

    // const walker = document.createTreeWalker(
    //   rootNode,
    //   NodeFilter.SHOW_TEXT, // only text nodes
    //   null,
    //   false
    // );

    // let node;
    // const nodesToProcess = [];
    // while ((node = walker.nextNode())) {
    //   nodesToProcess.push(node);
    // }

    // nodesToProcess.forEach(processNode);
  }

  // run squaggler
  walkAndSquaggle(document.body);

})();
