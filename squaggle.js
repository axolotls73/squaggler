
(function() {

  // these words block squaggling: only squaggle stuff in between
  // (lists of words from types of words generated by gemini)
  const BARRIER_WORDS = new Set([
    // articles
    'a', 'an', 'the',
    // boring verbs + helpers
    'am', 'are', 'be', 'been', 'being', 'can', 'could', 'did', 'do', 'does',
    'had', 'has', 'have', 'is', 'may', 'might', 'must', 'shall', 'should', 'was',
    'were', 'will', 'would',
    // pronouns
    'he', 'her', 'hers', 'him', 'his', 'i', 'it', 'its', 'me', 'mine',
    'my', 'our', 'ours', 'she', 'their', 'theirs', 'them', 'they', 'us', 'we',
    'you', 'your', 'yours',
    'that', 'these', 'this', 'those',
    'what', 'which', 'who', 'whom', 'whose',
    'herself', 'himself', 'itself', 'myself', 'ourselves', 'themselves', 'yourself', 'yourselves',
    // pronouns-ish
    'all', 'an', 'another', 'any', 'both', 'each', 'either', 'enough', 'every', 'few',
    'less', 'little', 'many', 'more', 'most', 'much', 'neither', 'no', 'one', 'other',
    'several', 'some', 'such', 'the',
    // prepositions
    'about', 'above', 'across', 'after', 'against', 'along', 'among', 'around', 'at', 'before',
    'behind', 'below', 'beneath', 'beside', 'between', 'beyond', 'by', 'down', 'during', 'for',
    'from', 'in', 'inside', 'into', 'near', 'of', 'off', 'on', 'out', 'over',
    'past', 'since', 'through', 'throughout', 'to', 'toward', 'under', 'underneath', 'until', 'unto',
    'up', 'upon', 'with', 'without',
    // conjunctions
    'but', 'for', 'nor', 'so', 'yet',
    // 'or',
    'after', 'although', 'as', 'because', 'before', 'if', 'once', 'since', 'than', 'that',
    'though', 'till', 'unless', 'until', 'when', 'whether', 'while',
    // question words
    'how', 'when', 'where', 'why',
    // misc words i don't want squaggled
    'due', "like",
    // punctuation is also "words" here, don't want to squaggle across sentence boundaries
    '.', '?', '!', ';', ':', '\'', '-', '–', '—',
    '"', '\'', '(', ')', '[', ']', '{', '}', '<', '>',
  ]);

  // these words don't block squaggling but aren't squaggled.
  // want e.g. bacon, lettuce, and tomato -> tacon, bettuce, and lomato
  const GHOST_WORDS = new Set([
    'and', 'or', ','
  ]);


  // get lowercased first consonant cluser of word (empty string if word starts w/ a vowel)
  function getFirstCluster(word) {
    let wl = word.toLowerCase();
    let vowels = 'aeiouy';
    let i = 0;
    for (; i < wl.length; i++) {
      if (vowels.includes(wl[i])) {
        break;
      }
    }
    ///TODO: handle weird words that are all consonants somewhere else?
    return wl.substring(0, i);
  }

  // squaggle list of (node, startindex, word) tuples
  // returns [node, startindex, endindex, replacement word] for modification
  function squaggleWords(words) {
    actualwords = words.filter(t => {
      return !(GHOST_WORDS.has(t[2].toLowerCase()));
    });
    if (actualwords.length <= 1) {
      return [];
    }
    console.log("squaggling:", words);

    // the actual squaggling operation: replace first consonant cluster
    // of words[i] with the first cluster of words [i+1] (mod array size)
    let replacements = [];
    for (let i = 0; i < actualwords.length; i++) {
      let [dstnode, dstindex, dstword] = actualwords[i];
      let srcword = actualwords[(i + 1) % actualwords.length][2];

      let dstcluster = getFirstCluster(dstword);
      let srccluster = getFirstCluster(srcword);
      let newword = (srccluster + dstword.slice(dstcluster.length)).toLowerCase();

      if (/[A-Z]/.test(dstword[0])) {
        newword = newword[0].toUpperCase() + newword.slice(1);
      }
      console.log("word", dstword, "dst", dstcluster, "src", srccluster, "squaggled word:", newword);
      replacements.push([dstnode, dstindex, dstindex + dstword.length, newword]);
    }

    console.log("replacements:", replacements);
    return replacements;
  }

  // squaggles list of (node, text) tuples
  // this function is the one that actually applies modifications to the nodes
  function squaggleSequence(seq) {
    let wordlist = [];
    let squagglereplacements = [];
    for (const [node, text] of seq) {
      const wordregex = /\b[a-zA-Z]+(?:['\-][a-zA-Z]+)*\b/gs;
      const matches = text.matchAll(wordregex);

      for (const match of matches) {
        let word = match[0];
        console.log("processing word: ", word);
        // hit barrier: current word list complete, send to squaggle and start over
        // (numbers are also barriers)
        let barrier = BARRIER_WORDS.has(word.toLowerCase()) || /\d/.test(word[0]);
        if (barrier) {
          squagglereplacements = squagglereplacements.concat(squaggleWords(wordlist));
          wordlist = [];
        }
        else {
          wordlist.push([node, match.index, word]);
        }
      }
    }

    // apply replacements to squaggle nodes (in reverse order by startindex)
    squagglereplacements.sort((a, b) => b[1] - a[1]);
    console.log(squagglereplacements);
    for ([node, start, end, newword] of squagglereplacements) {
      let originaltext = node.nodeValue;
      let newtext = originaltext.slice(0, start) + newword + originaltext.slice(end)
      console.log(node, "after replacement:", newtext);
      node.nodeValue = newtext;
    }
  }

  // squaggles children as a single unit
  function squaggleNode(root) {
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
    const sequence = [];

    let node;
    while (node = walker.nextNode()) {
      const text = node.nodeValue;

      // skip whitespace
      if (!text.trim()) {
        continue;
      }
      sequence.push([node, text]);
    }
    console.log("p sequence:", sequence);

    squaggleSequence(sequence);
  }

  // function processNode(node) {
  //   console.log("processing: " + node.tagName);
  //   if (!node.nodeValue || !(node.nodeValue.trim().length > 2)) {
  //     return;
  //   }

  //   let parent = node.parentElement;
  //   while (parent && parent !== document.body) {
  //     const tagName = parent.tagName.toUpperCase();
  //     if (tagName === 'SCRIPT' || tagName === 'STYLE' || tagName === 'NOSCRIPT' || tagName === 'CODE' || tagName === 'PRE') {
  //       return;
  //     }
  //     parent = parent.parentElement;
  //   }

  //   console.log(node.nodeValue);
  //   node.nodeValue = 'a' + node.nodeValue;
  // }

  function walkAndSquaggle(rootNode) {
    const ps = document.querySelectorAll('p');
    for (p of ps) {
      squaggleNode(p);
    }

    // const walker = document.createTreeWalker(
    //   rootNode,
    //   NodeFilter.SHOW_TEXT, // only text nodes
    //   null,
    //   false
    // );

    // let node;
    // const nodesToProcess = [];
    // while ((node = walker.nextNode())) {
    //   nodesToProcess.push(node);
    // }

    // nodesToProcess.forEach(processNode);
  }

  // run squaggler
  walkAndSquaggle(document.body);

})();
