
(function() {

  // these words block squaggling: only squaggle stuff in between
  // (lists of words from types of words generated by gemini)
  const BARRIER_WORDS = new Set([
    // articles
    'a', 'an', 'the',
    // boring verbs + helpers
    'am', 'are', 'be', 'been', 'being', 'can', 'could', 'did', 'do', 'does',
    'had', 'has', 'have', 'is', 'may', 'might', 'must', 'shall', 'should', 'was',
    'were', 'will', 'would',
    // pronouns
    'he', 'her', 'hers', 'him', 'his', 'i', 'it', 'its', 'me', 'mine',
    'my', 'our', 'ours', 'she', 'their', 'theirs', 'them', 'they', 'us', 'we',
    'you', 'your', 'yours',
    'that', 'these', 'this', 'those',
    'what', 'which', 'who', 'whom', 'whose',
    'herself', 'himself', 'itself', 'myself', 'ourselves', 'themselves', 'yourself', 'yourselves',
    // pronouns-ish
    'all', 'an', 'another', 'any', 'both', 'each', 'either', 'enough', 'every', 'few',
    'less', 'little', 'many', 'more', 'most', 'much', 'neither', 'no', 'one', 'other',
    'several', 'some', 'such', 'the',
    // prepositions
    'about', 'above', 'across', 'after', 'against', 'along', 'among', 'around', 'at', 'before',
    'behind', 'below', 'beneath', 'beside', 'between', 'beyond', 'by', 'down', 'during', 'for',
    'from', 'in', 'inside', 'into', 'near', 'of', 'off', 'on', 'out', 'over',
    'past', 'since', 'through', 'throughout', 'to', 'toward', 'under', 'underneath', 'until', 'unto',
    'up', 'upon', 'with', 'without',
    // conjunctions
    'but', 'for', 'nor', 'so', 'yet',
    // 'or',
    'after', 'although', 'as', 'because', 'before', 'if', 'once', 'since', 'than', 'that',
    'though', 'till', 'unless', 'until', 'when', 'whether', 'while',
    // question words
    'how', 'when', 'where', 'why',
    // misc words i don't want squaggled
    'due', "like",
    // punctuation is also "words" here, don't want to squaggle across sentence boundaries
    '.', '?', '!', ';', ':', '\'', '-', '–', '—',
    '"', '\'', '(', ')', '[', ']', '{', '}', '<', '>',
  ]);

  // these words don't block squaggling but aren't squaggled.
  // want e.g. bacon, lettuce, and tomato -> tacon, bettuce, and lomato
  const GHOST_WORDS = new Set([
    'and', 'or', ','
  ]);


  // get lowercased first consonant cluser of word (empty string if word starts w/ a vowel)
  function getFirstCluster(word) {
    let wl = word.toLowerCase();
    let vowels = 'aeiouy';
    let i = 0;
    for (; i < wl.length; i++) {
      if (vowels.includes(wl[i])) {
        break;
      }
    }
    ///TODO: handle weird words that are all consonants somewhere else?
    return wl.substring(0, i);
  }

  // squaggle list of (node, startindex, word) tuples
  // this function is the one that actually applies modifications to the nodes
  function squaggleWords(words) {
    actualwords = words.filter(t => {
      return !(GHOST_WORDS.has(t[2].toLowerCase()));
    });
    if (actualwords.length <= 1) {
      return;
    }

    // the actual squaggling operation: replace first consonant cluster
    // of words[i] with the first cluster of words [i+1] (mod array size)
    for (let i = 0; i < actualwords.length; i++) {
      let [dstnode, dstindex, dstword] = actualwords[i];
      let srcword = actualwords[(i + 1) % actualwords.length][2];

      let dstcluster = getFirstCluster(dstword);
      let srccluster = getFirstCluster(srcword);
      let newword = srccluster + dstword.slice(dstcluster.length)

      if (/[A-Z]/.test(dstword[0])) {
        newword = newword[0].toUpperCase() + newword.slice(1);
      }
      console.log("word", dstword, "dst", dstcluster, "src", srccluster, "squaggled word:", newword);
    }

    console.log("squaggling: ", actualwords);
  }

  // squaggles list of (node, text) tuples
  function squaggleSequence(seq) {
    let wordlist = [];
    for (const [node, text] of seq) {
      const wordregex = /\b[a-zA-Z]+(?:['\-][a-zA-Z]+)*\b/gs;
      const matches = text.matchAll(wordregex);

      for (const match of matches) {
        let word = match[0];
        console.log("processing word: ", word);
        // hit barrier: current word list complete, send to squaggle and start over
        // (numbers are also barriers)
        let barrier = BARRIER_WORDS.has(word.toLowerCase()) || /\d/.test(word[0]);
        if (barrier) {
          squaggleWords(wordlist);
          wordlist = [];
        }
        else {
          wordlist.push([node, match.index, word]);
        }
      }
    }
  }

  // squaggles children as a single unit
  function squaggleNode(root) {
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
    const sequence = [];

    let node;
    while (node = walker.nextNode()) {
      const text = node.nodeValue;

      // skip whitespace
      if (!text.trim()) {
        continue;
      }
      sequence.push([node, text]);
    }
    console.log("p sequence:", sequence);

    squaggleSequence(sequence);
  }

  // function processNode(node) {
  //   console.log("processing: " + node.tagName);
  //   if (!node.nodeValue || !(node.nodeValue.trim().length > 2)) {
  //     return;
  //   }

  //   let parent = node.parentElement;
  //   while (parent && parent !== document.body) {
  //     const tagName = parent.tagName.toUpperCase();
  //     if (tagName === 'SCRIPT' || tagName === 'STYLE' || tagName === 'NOSCRIPT' || tagName === 'CODE' || tagName === 'PRE') {
  //       return;
  //     }
  //     parent = parent.parentElement;
  //   }

  //   console.log(node.nodeValue);
  //   node.nodeValue = 'a' + node.nodeValue;
  // }

  function walkAndSquaggle(rootNode) {
    console.log("SQUAGGLE");
    const ps = document.querySelectorAll('p');
    for (p of ps) {
      squaggleNode(p);
      break;
    }

    // const walker = document.createTreeWalker(
    //   rootNode,
    //   NodeFilter.SHOW_TEXT, // only text nodes
    //   null,
    //   false
    // );

    // let node;
    // const nodesToProcess = [];
    // while ((node = walker.nextNode())) {
    //   nodesToProcess.push(node);
    // }

    // nodesToProcess.forEach(processNode);
  }

  // run squaggler
  walkAndSquaggle(document.body);

})();
